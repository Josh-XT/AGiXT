import ast
from typing import Any, Callable, Dict
from transformers.tools.python_interpreter import InterpretorError, evaluate_ast

def evaluate(code: str, tools: Dict[str, Callable], state=None, chat_mode=False):
    try:
        expression = ast.parse(code)
    except SyntaxError as e:
        print("The code generated by the agent is not valid.\n", e)
        return
    if state is None:
        state = {}
    result = None
    for idx, node in enumerate(expression.body):
        try:
            line_result = evaluate_custom(node, state, tools)
        except InterpretorError as e:
            msg = f"Evaluation of the code stopped at line {idx} before the end because of the following error"
            if chat_mode:
                msg += (
                    f". Copy paste the following error message and send it back to the agent:\nI get an error: '{e}'"
                )
            else:
                msg += f":\n{e}"
            print(msg)
            break
        if line_result is not None:
            result = line_result
    return result

def evaluate_custom(expression: ast.AST, state: Dict[str, Any], tools: Dict[str, Callable]):
    if isinstance(expression, ast.Assign):
        return evaluate_assign(expression, state, tools)
    elif isinstance(expression, ast.Call):
        return evaluate_call(expression, state, tools)
    elif isinstance(expression, ast.Expr):
        return evaluate_custom(expression.value, state, tools)   
    elif isinstance(expression, ast.BinOp):
        left = evaluate_custom(expression.left, state, tools)
        right = evaluate_custom(expression.right, state, tools)
        left = evaluate_operator(left, expression.op, right)
        return left
    elif isinstance(expression, ast.AugAssign):
        target = expression.target.id
        value = evaluate_custom(expression.value, state, tools)
        state[target] = evaluate_operator(state[target], expression.op, value)
        return state[target]
    elif isinstance(expression, ast.For):
        line_result = target = targets = None
        if isinstance(expression.target, ast.Name):
            target = expression.target.id
        elif isinstance(expression.target, ast.Attribute):
            targets = [name.id for name in expression.target.elts]
        for value in evaluate_custom(expression.iter, state, tools):
            if target:
                state[target] = value
            elif targets:
                for i, v in enumerate(targets):
                    state[v] = value[i]
            for line in expression.body:
                line_result = evaluate_custom(line, state, tools)
        return line_result
    elif isinstance(expression, ast.Tuple):
        return [evaluate_ast(elt, state, tools) for elt in expression.elts]
    elif isinstance(expression, ast.Call) and isinstance(expression.func, ast.Name) and expression.func.id == "enumerate":
        return enumerate(evaluate_ast(expression.args[0], state, tools))
    else:
        return evaluate_ast(expression, state, tools)

def evaluate_assign(assign, state, tools):
    var_names = assign.targets
    result = evaluate_custom(assign.value, state, tools)

    if len(var_names) == 1:
        state[var_names[0].id] = result
    else:
        if len(result) != len(var_names):
            raise InterpretorError(f"Expected {len(var_names)} values but got {len(result)}.")
        for var_name, r in zip(var_names, result):
            state[var_name.id] = r
    return result

def evaluate_operator(left, op: ast.operator, right):
    if isinstance(op, ast.Add):
        left += right
    elif isinstance(op, ast.Sub):
        left -= right
    elif isinstance(op, ast.Mult):
        left *= right
    elif isinstance(op, ast.Div):
        left /= right
    else:
        raise InterpretorError(f"Unknown operator: {op}")
    return left

def evaluate_call(call, state, tools):
    if isinstance(call.func, ast.Attribute) and call.func.attr == "replace":
        if isinstance(call.func.value, ast.Name):
            target = call.func.value.id
            target = state[target]
        else:
            target = evaluate_custom(call.func.value, state, tools)
        func = target.replace
    else:
        if not isinstance(call.func, ast.Name):
            raise InterpretorError(
                f"It is not permitted to evaluate other functions than the provided tools (tried to execute {call.func} of "
                f"type {type(call.func)}."
            )
        func_name = call.func.id
        if func_name not in tools:
            raise InterpretorError(
                f"It is not permitted to evaluate other functions than the provided tools (tried to execute {call.func.id})."
            )
        func = tools[func_name]
    args = [evaluate_ast(arg, state, tools) for arg in call.args]
    kwargs = {keyword.arg: evaluate_custom(keyword.value, state, tools) for keyword in call.keywords}
    return func(*args, **kwargs)